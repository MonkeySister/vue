### v-if与v-show的区别

**v-show**

在v-show中，元素是一直存在的，当v-show为false时，元素display:none只是隐藏了而已。 

**v-if**

作用：判断是否加载固定的内容，如果为真，则加载；为假时，则不加载。

用处：用在权限管理，页面条件加载。

语法：v-if=“判断表达式”

特点：控制元素插进来或者删除，而不是隐藏。

 

**一般的，v-if有更高的切换消耗，而v-show有更多的初始化渲染消耗。**

**如果需要频繁的切换而对安全性无要求，使用v-show。如果在运行时，条件不可能改变，则使用v-if较好。**

### 什么是闭包以及闭包的优缺点

js的特点，函数内部可以读取函数内部以及全局变量，函数外部无法读取函数内部的变量，在函数内部命名变量时一定要使用var 不然就成为了全局变量，这就是啊js的链式作用域。

有时候我们要在外部访问到函数内部的变量于是闭包就产生了。

在函数的内部在定义一个函数，而这个函数可以访问父函数的变量，返回父函数的变量，我们就可以拿到父函数里面的变量了。

闭包就是能够读取其他函数内部变量的函数；

闭包可以简单的理解为定义在一个函数内部的函数；

在本质上，闭包是将函数外部与内部连接起来的桥梁；

#### 闭包的优点

可以读取函数内部的变量，

可以让这些变量始终保存在内存中，不会在函数调用后自动清除

#### 闭包的缺点

由于闭包会是函数的变量始终保存在内存中，对内存的消耗大，会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 

### Html5中的webstock

在单个TCP上进行全双工通信的协议，只需要一次握手就可以实现数据传输；连接建立后可以通过send向服务端发送数据，然后通过onmessage接收后台返回的数据。

### 网页性能优化的方法

1. html标签语义化
2. 减少重复的代码，压缩css，封装js
3. 控制背景图片的大小及数量，使用图片懒加载
4. 减少http请求
5. 减少DOM操作
6. 使用CDN加速
7. 跨域时使用反向代理

### 网站安全问题

#### xss跨站脚本攻击

 XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。XSS 的攻击方式千变万化，但还是可以大致细分为几种类型 。

##### 非持久型xss

带有恶意脚本参数的URL，盗取用户信息。

解决办法：

1. 前端渲染的内容或者数据都必须来自服务端。
2. 不要从URL或者DOM API中获取数据渲染。
3. 尽量不要使用可执行字符串的方法。
4. 前端渲染的时候对任何字段都要做escape转义。



### 请简单介绍下Vue

vue是一套Javascript框架，有一整套完整的解决方案，它最大程度上解放了DOM操作，开发单页SPA（网页所有内容都在一个页面里）项目，有着双向数据绑定，解耦视图与数据，可复用组件，虚拟DOM,MVVM架构，数据驱动视图的特点。

vue.js不支持IE8及其以下版本

### 什么是虚拟DOM

首先什么是DOM:浏览器解析HTML文档生成的一个树形逻辑对象。

为什么要有虚拟DOM:浏览器频繁的操作真实DOM会带来一系列的性能问题。加载渲染速度慢，影响用户体验。

什么是虚拟DOM:虚拟DOM使用js创建，是关于真实DOM的映射，和浏览器没有任何的联系。

虚拟DOM到真实DOM:虚拟DOM根据数据的变化，使用diff算法与旧的虚拟DOM进行对比，然后根据修改将新的虚拟DOM修改到浏览器的真实DOM上。

核心：通过javascript对象表示的树结构来创建一颗真正的DOM树，当数据状态发生改变时，可以直接修改这个对象，接着对比修改后的js对象，记录下需要对页面做的dom操作，然后将其运用到真正的DOM树，实现视图的更新。

### 什么是MVVM架构

M:model负责数据的存储

V:view负责数据的展示，也就是界面

VM:数据改变视图改变，视图改变数据改变，vue内置实现。

### vue中常用指令

v-for:循环渲染绑定的数组；

v-on/@click:事件绑定，事件触发时调用；

v-if和v-show:v-if是否加载内容，v-show是否渲染内容；v-show有更高的渲染消耗，v-if有更高的切换开销。

v-text和v-html：v-text更新整个标签，插值表达式更新标签中的内容；v-html避免使用会触发xss跨站脚本攻击（跨域请求伪造）。

v-bind：可以绑定标签上的任何属性。

v-model：双向数据绑定。

v-cloak:防止看到插值表达式。

v-once:只渲染一次，优化更新性能。

### 过滤器

1. 在vm实例中配置过滤器
2. 过滤器名字，匿名函数
3. 使用过滤器

```
<div id="app">
    <!-- 3. 调用过滤器: (msg会自动传入到toUpper中)-->
    <p>{{msg | toUpper}}</p>
</div>
<script src="./vue.js"></script>
<script>
    // 1. 定义全局过滤器
    Vue.filter('toUpper', (value) => {
        console.log(value);
        // 2. 操作数据并返回
        value = value.charAt(0).toUpperCase() + value.substr(1).toLowerCase();
        console.log(value);
        return value;
    });

    new Vue({
        el: '#app',
        data: {
            msg: 'hello'
        },
        methods: {

        }
    });
</script>
```

### Vue中有关DOM的操作

在vue中操作dom；

1. 给dom添加ref属性;ref="txt"
2. this.$ref.txt.focus();

### 计算属性

computed:{}:计算属性其实就是一个属性，是一个带有返回值的方法；

```

```

computed与methods中的方法：

1. 一旦data中的数据发生变化，就会触发计算属性，会将data中属性的结果进行环迅，对比缓存的结果是否发生变化。
2. methods一调用就会触发和数据的变化无关。

### 组件间传值

1. 父传子

   通过在子组建中定义prop来接收父组件的传值，可以是对象或者数组。

2. 子传父

   在子组件中触发事件，在事件中调用this.$emit('父组件中通过v-on监听的方法'，要传的值)。

3. 兄弟间传值

   

### 单页面应用SPA

概念：在一个页面内完成所有的业务功能。

优点：操作流程，完全的前端组件化

缺点：首次加载大量资源，对搜索引擎不好(页面局部刷新，引擎爬取不到数据)->服务端渲染，开发难受相对较高。

实现原理：

前后端分离，

hash路由，hash改变不会引起页面刷新，当url的hash改变时可以触发hashchange回调函数。

history路由：history路由是基于HTML5规范，在h5中提供了 *history.pushState || history.replaceState* 来进行路由控制

### vue-router

这个问的比较多：说一下vue-router

是vue.js官方路由管理器，根据不同的请求地址显示不同的组件。

1. 导入vue-router

2. 将组件映射到路由然后在router-view中渲染组件，router-view默认被渲染为a标签。

3. 动态路由：

   可以在路由中传参，并且可以在this.$route.params中拿到参数。

   可以使用watch来监测路由参数的变化。

   或者可以使用beforeRouteUpdata导航守卫来监测，

4. 嵌套路由：

   在路由与组件的映射中通过children来设置被嵌套的路由。可以嵌套一个也可以嵌套多个。不要以/开头，以 / 开头的嵌套路径会被当作根路径。

5. 编程式导航

   除了用router-link ：to='组件名'来导航外，还可以通过

   router.push({ name: 'user', params: { userId }}) // -> /user/123

   router.push({ path: `/user/${userId}` }) // -> /user/123编程式导航的传参

   来导航

   router.replace(),不会添加浏览记录，会替换掉当前的历史记录。

   router.go()在历史中前进后退多少步。

6. 命名路由name

   在路由配置中为对路由进行配置，然后可以在书写式或者编程式导航中通过name来进行路由跳转。

7. 命名视图

   一个路由同时显示多个视图，也就是多个router-view同时显示，可以给视图通过name进行命名，同时在路由配置的组件中填写多个组件名。

8. 重定向

   ```
   const router = new VueRouter({
     routes: [
       { path: '/a', redirect: '/b' }
     ]
   })
   ```

   也可以写成命名路由。

   别名：/a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。

9. 路由组件传参

   通过prop解耦路由和组件，是组件的使用更加灵活。

10. 导航守卫

    router.beforeEach((to,from,next)=>{

    })

11. 完整的导航解析流程

    1. 导航被触发。
    2. 在失活的组件里调用离开守卫。
    3. 调用全局的 `beforeEach` 守卫。
    4. 在重用的组件里调用 `beforeRouteUpdate` 守卫 (2.2+)。
    5. 在路由配置里调用 `beforeEnter`。
    6. 解析异步路由组件。
    7. 在被激活的组件里调用 `beforeRouteEnter`。
    8. 调用全局的 `beforeResolve` 守卫 (2.5+)。
    9. 导航被确认。
    10. 调用全局的 `afterEach` 钩子。
    11. 触发 DOM 更新。
    12. 用创建好的实例调用 `beforeRouteEnter` 守卫中传给 `next` 的回调函数。

12. 路由懒加载

    把组件按组分块，分块加载。

### 服务端渲染SSR

概念：将一个组件在服务器端渲染为html字符串，然后直接发送给浏览器进行渲染。

优点：有利于搜索引擎SEO，网页运行速度更快

缺点：服务端负载更多

### vue渐进式框架的理解

比较低的局限性，比较少的硬性要求，自由发挥的空间比较大。

### vue的两大核心数据驱动和组件

### vue常用修饰符

.prevent:阻止默认行为

.stop：阻止事件冒泡

.once：只修饰一次

.lazy：光标离开数据更新

.number:输入自动取成数值

.trim:过滤空字符串

### v-on可以绑定多个方法

### vue中key的作用

key，标识组件的唯一性，高效地更新虚拟DOM

### $nextClick

$nextTick 是在下次 DOM 更新循环结束之后（mounted结束后调用，延迟回调）执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM。 

### v-for和v-if的优先级

v-for的优先级比较高，可以将v-if置于外层元素上。

### 子组件中调用父组件中的方法

1. this.$parent.事件名。
2. 子组件里用`$emit`向父组件触发一个事件 
3. 通过prop接受来自父组件中的方法